# Becoming a 10X Developer
Catchy title, right?!

## Introduction
For now, this is just a fluid outline for structuring my thoughts as the book is
coming together in disparate pieces. As of now, the outline is growing
intractably.

## Outline
- Motivation
    * Why take the difficult path? There are many easier and quicker ways to
        learn to program. This is for people who wish to be masters of the
        field.
- Intended Audience
- Math
    * Liner Algebra
    * Discreet Math
    * Statistics
    * Proofs
- Computability
    * What is computation
    * Turing Machines
    * Automata
- Hardware
    * Von Neumann Architecture
    * Memory Hierarchy
    * Input/Output - peripherals
    * Networking - How machines communicate
- Memory
    * Virtual Memory vs. Physical memory
    * Memory Addressing
    * Process memory layout
- Asymptotic Complexity
    * Measuring Performance by defining growth rate
    * Big 0 Notation
    * Big Theta
    * Big Omega
    * P vs. NP
- Data Structures
    * Abstract Data Structures
        - Priority Queue
    * List Data Structures
        - Array
        - Linked List
        - Sorted Array
        - Binary Tree
        - Red-Black Tree
    * Functional Data Structures
        - Stack
        - Queue
        - Binary Heap
        - Fibonacci Heap
        - Hash Table
        - Bloom Filter
- Novel Data Structure Uses
    * This shows a few way to combine data structures together
    * Running Median
- Hashing
- Algorithms
    - Sorting
        - Bubble Sort
        - Insertion Sort
        - Selection Sort
        - Merge Sort
        - Quick Sort
        - What is an algorithm
    * Common Design Paradigms
        - Divide and Conquer
            * Merge Sort
        - Randomized Algorithms
            * Quick Sort with random pivot element
        - Greedy Algorithms
        - Dynamic Programming
    * Quick Select
- Graphs
    * Graph Concepts
    * Graph Search
    * Shortest Path
    * Random Contraction
- Programming Paradigms
    * Structured
    * Object Oriented 
    * Functional
    * Logical
- Threading
    * Processes
    * Threads
    * Asynchrony
    * Concurrency
- Databases
    * Relational
    * Document
- Internet
- System Design Concepts

A man once asked Mozart how to write a symphony. Mozart told him to study at the
conservatory for six or eight years, then apprentice with a composer for four or
five more years, then begin writing a few sonatas, pieces for string quartets,
piano concertos, etc. and in another four or five years he would be ready to try
a full symphony.  The man said, "But Mozart, didn't you write a symphony at age
eight?" Mozart replied, "Yes, but I didn't have to ask how."

Concentrate on enduring software engineering concepts. It's easy to learn
frameworks and the skill is fleeting.

While it's true that most programmers will never have to create these algorithms
from scratch, understanding them is absolutely requisite.

Attempting to master programming without understanding the underlying
mathematical principals is like tying to learn English without understanding
basic sentence structure.

It's hard to create a beautiful and elegant algorithm without seeing examples of
beauty and elegance.

Provides common useful patterns, useful tools that have proven themselves over
time. Not everyone who uses a hammer builds tables.

Do not interpret these examples as absolutely canonical. There is no one right
way to do things. Software engineering is all about choosing the right balance
of trade offs that work best for a particular application.
